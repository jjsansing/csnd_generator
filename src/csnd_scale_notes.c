/**
 * /file csnd_scale_notes.c
 * <h3> CSound Scale Notes Generator Program</h3>
 *
 ************************************************************************
 * <hr><p>
 * Copyright (C) 2020 Jim Sansing
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 * <hr><p>
 ************************************************************************
 *
 *
 * Input Data
 * - Staves filename (default = csg_staves.<scalename>)
 *   - Scale names are the steps where:
 *     h = half tone, w = whole tone, m = minor 3rd, M = major 3rd, f = fourth,
 *     d = diminished fifth, F = fifth, a = augmented fifth, s = sixth,
 *     A = augmented sixth, S = seventh, j = major seventh, e = eighth,
 *     n = diminished ninth, N = ninth, t = diminished tenth, T = tenth,
 *     v = diminished eleventh, V = eleventh, l = diminished twelfth, L = twelfth,
 *     r = diminished thirteenth, R = thirteenth, o = diminished fourteenth, O = fourteenth
 * - Note definition filename
 *   - Definitions must include octave 0:  NOTE 0A 29.49
 * - Scale staves example filename (default = sn_example)
 * - Number of notes in a scale (excluding octave)
 * - Maximum number of steps (default = 4 : major 3rd, maximum = 25 : fourteenth)
 * - First scale to generate (default = 1)
 * - Maximum number of scales to generate (default = all)
 * - Number of scales to group in 1 file
 *
 *
 * Output Data
 * - csg_staves.<filename>
 *
 * Functions
 * - Parse note definition file
 * - Generate all unique scales 
 * - Create staves file for each or group
 */

#include "csnd_scale_notes.h"

#define SN_VER "1.0"

#define CSG_HEADER "# These staff definitions were generated by the Scale Notes Generator 1.0\n#\n"

char vfile[SN_MAX_FN];  // Staves filename
char nfile[SN_MAX_FN];  // Notes filename
char sfile[SN_MAX_FN];  // Example filename

int sn_tuning_size = 0;
int sn_scale_len = DFLT_SCALE_LEN;
int sn_max_interval = DFLT_INTERVAL;
int sn_first_scale = 1;
int sn_max_scales = 0x7fffffff;
// TODO: Implement groups of scales in a csg_staves file
int sn_group_size = 1;
double sn_group_interval = 0.0;

char sn_intervals[] = {" hwmMfdFasASjenNtTvVlLrRoO"};

snMain *anchor;

/**
  * \par Function:
  *   sn_alloc
  *
  * \par Description:
  *   This is a utility function to allocate data structures.  It initializes
  *   the space to 0s.
  *
  * \par Inputs:
  *   - datasz: Amount of memory to be allocated
  *   - dmsg: Data type being allocated
  *
  * \par Outputs:
  *   - char pointer
  *     - NULL = Error
  */

char * sn_alloc(int datasz, char *dmsg)
{
    char *datastruct;

    if ((datastruct = (char *) malloc(datasz)) == NULL)
    {
        printf("Error: could not allocate %s\n  %s\n", dmsg, strerror(errno));
        return NULL;
    }
    memset(datastruct, 0, datasz);
    return datastruct;
}

/**
  * \par Function:
  *   sn_print_data;
  *
  * \par Description:
  *   This is a utility function to print data.
  *
  * \par Inputs:
  *   - datatypes: Bit flag to indicate datatypes
  *
  * \par Outputs:
  *   - None
  */

#define DEBUG_NOTE      0x01
#define DEBUG_SCALE     0x02
#define DEBUG_STAFF     0x04

#define TYPE_NOTE       0x0001
#define TYPE_SCALE      0x0002
#define TYPE_STAFF      0x0004

void sn_print_data(int datatypes)
{
    int i;
    snNote *note;
    snScale *scale;
    snStaff *staff;
    snStaffNote *stnote;
    snPattern *pat;

    if (datatypes & TYPE_NOTE)
    {
        note = anchor->notes;
        while (note != NULL)
        {
            printf("Note '%s'\n", note->name);
            note = note->next;
        }
    }

    if (datatypes & TYPE_SCALE)
    {
        scale = anchor->scales;
        if (anchor->xpat != NULL)
        {
            printf("Exclude patterns:\n");
            pat = anchor->xpat;
            while (pat != NULL)
            {
                printf("  %s", pat->pat);
                pat = pat->next;
            }
            printf("\n");
        }
        printf("Total Scales: %d\n", anchor->scalesz);
        while(scale != NULL)
        {
            printf("Scale '");
            for (i = 0; i < sn_scale_len; i++)
                printf("%d", scale->scale[i]);
            printf("' :: '");
            /* sn_intervals[] = {" hwmMfdFasASjenNtTvVlLrRoO"} */
            // for (i = 0; i < sn_scale_len; i++)
                // printf("%c", sn_intervals[scale->scale[i]]);
            printf("%s", scale->name);
            printf("' :: '");
            for (i = 0; i < sn_scale_len; i++)
                printf("%d", scale->idx[i]);
            printf("'\n");
            scale = scale->next;
        }
        printf("Total Scales: %d\n", anchor->scalesz);
    }

    if (datatypes & TYPE_STAFF)
    {
        staff = anchor->staffs;
        while (staff != NULL)
        {
            printf("%s\n", staff->name);
            printf("%s", staff->instr);
            stnote = staff->notes;
            while (stnote != NULL)
            {
                printf("%s", stnote->line);
                stnote = stnote->next;
            }
            staff = staff->next;
        }
    }

}

/**
  * \par Function:
  *   sn_getnum
  *
  * \par Description:
  *   This is a utility function to parse numeric values.  The values can
  *   be simple integers or decimals in any format and precision.
  *
  * \par Inputs:
  *   - line: Line to be parsed, starting at number to be parsed
  *
  * \par Outputs:
  *   - double: Result
  *     - DBL_ERROR = -99999.999 returned if error
  */

double sn_getnum(char *line)
{
    int i= 0, j = 0, found = 0;
    double tnum;
    char nbuf[32], *ept;

    memset(nbuf, 0, 32);

    do {
        if (line[i] == ' ' || line[i] == '\t' || line[i] == '\0' || line[i] == '\n')
        {
            if (j > 0)
            {
                nbuf[j] = '\0';
                tnum = strtod(nbuf, &ept);
                found = 1;
                if (*ept != '\0')
                {
                    printf("Error: invalid numeric value: '%s'\n  %s\n", nbuf, line);
                    return DBL_ERROR;
                }
            }
            else
            {
                printf("Error: numeric value not found:\n  %s\n", line);
                return DBL_ERROR;
            }
        }
        nbuf[j++] = line[i++];
    } while (!found);
    
    return tnum;
}

/** 
 * \par Function:
 *   sn_parse_notes
 * 
 * \par Description:
 *   Parse the notes file which contains the list of notes in the tuning.
 *
 *   The format of the note file is as follows:
 *
 *   <br>Comments are indicated by preceeding a line with '#', and blank
 *   lines are permitted.
 *   <br>NOTE name instrument
 *   - name: <note> <modifier> 
 *     - note: A - Z and a - z case sensitive
 *     - modifiers:  Blank, 0 - 9, A - Z, or a - z
 *
 * \par Inputs:
 *   - notefn: Name of note file to parse
 *
 * \par Outputs:
 *   - int: Status
 *     - 0 = OK
 *     - <0 = Error
 */

int parse_notes(char *notefn)
{
    int i;
    char line[SN_MAX_LINE];
    FILE *nfd;
    snNote *note = NULL;

    if ((nfd = fopen(notefn, "r")) == NULL)
    {
        printf("Error: failed to open note file %s\n  %s\n", notefn,
strerror(errno));
        goto pn_error;
    }

    while (!feof(nfd) && !(ferror(nfd)))
    {
        if (fgets(line, SN_MAX_LINE, nfd) == NULL)
        {
            if (feof(nfd))
                break;
            else if (ferror(nfd))
            {
                printf("Error: attempting to read from note file %s\n  %s\n",
                        notefn, strerror(errno));
                goto pn_error;
            }
            continue;
        }
        /* Check for blank lines and comments */
        for (i=0; i < SN_MAX_LINE; i++)
        {
            if (line[i] == '\0' || line[i] == '\n' || line[i] == '#')
            {
                i = SN_MAX_LINE;
                break;
            }
            else if (line[i] != ' ' || line[i] == '\t')
                break;
        }
        if (i >= SN_MAX_LINE)
            continue;
        if (strncmp(&line[i], "NOTE", 4) == 0)
        {
            if ((note = (snNote *) sn_alloc(sizeof(snNote), "note data")) ==
NULL)
                goto pn_error;
            i += 5;
            strncpy(note->name, &line[i], 2);
            if (!( (note->name[1] >= '0' && note->name[1] <= '9') ||
                   (note->name[1] >= 'a' && note->name[1] <= 'z') ||
                   (note->name[1] >= 'A' && note->name[1] <= 'Z') ))
                note->name[1] = '\0';
            if (anchor->notes == NULL)
            {
                anchor->notes = note;
                anchor->ntail = note;
                anchor->notesz++;
            }
            else
            {
                anchor->ntail->next = note;
                anchor->ntail = note;
                anchor->notesz++;
            }
            sn_tuning_size++;
        }
    }

    fclose(nfd);
    return 0;

pn_error:
    if (nfd != NULL)
        fclose(nfd);
    printf("Error getting note in line: '%s'\n", line);
    return -1;
}

/** 
 * \par Function:
 *   sn_get_unique_scales
 * 
 * \par Description:
 *   Calculate the list of unique scales based on the tuning and scale criteria.
 *
 * \par Inputs:
 *   - None
 *
 * \par Outputs:
 *   - int: Status
 *     - 0 = OK
 *     - <0 = Error
 */

int sn_get_unique_scales()
{
    int idx, ci, jdx, unique;
    int scale_cnt = 1, interval_total = 0, done = 0, loopcnt = 0;
    char *scale_arr, *scale_steps = NULL;
    snPattern *pat;
    snScale *scale;

    /* Build list of unique scales                           */
    /* - Get variables: tuning_size, scale_len, max_interval */
    /* - Find first scale: array[scale_len] = {1,1,1,...}    */
    if ((scale_arr = (char *) sn_alloc(sn_scale_len * 2, "scale array")) == NULL)
        goto gus_error;
    for (idx = 0; idx < sn_scale_len; idx++)
        scale_arr[idx] = 1;
    if ((scale_steps = (char *) sn_alloc(sn_scale_len * 2, "scale array")) == NULL)
        goto gus_error;
    /* - Add all intervals, (if = tuning_size) test for dupes, (if unique) keep */
    printf("Get unique scales: ");
    while (!done)
    {
        if ((loopcnt & 0xfff) == 0)
        {
            printf(".");
            fflush(stdout);
        }
        loopcnt++;
        interval_total = 0;
        unique = 1;
        for (idx = 0; idx < sn_scale_len; idx++)
            interval_total += scale_arr[idx];
        for (idx = 0; idx < sn_scale_len; idx++)
        {
            ci = (int) scale_arr[idx];
            scale_steps[idx] = sn_intervals[ci];
        }
        if (interval_total == sn_tuning_size)
        {
            /* Use scale copy to test for duplicates starting at */
            /* different points in the scale                     */
            for (idx = 0; idx < sn_scale_len; idx++)
                scale_arr[idx + sn_scale_len] = scale_arr[idx];
            /* Test for exclude patterns */
            if (anchor->xpat != NULL)
            {
                pat = anchor->xpat;
                while (pat != NULL)
                {
                    for(idx = 0; idx < sn_scale_len; idx++)
                    {
                        if (strncmp(&scale_steps[idx], pat->pat, pat->len) == 0)
                        {
                            unique = 0;
                            break;
                        }
                    }
                    if (unique)
                        pat = pat->next;
                    else
                        break;
                }
            }
            /* Test for duplicates */
            scale = anchor->scales;
            while (unique && scale != NULL)
            {
                for (idx = 0; idx < sn_scale_len; idx++)
                {
                    if (scale_arr[idx] == scale->scale[0])
                    {
                        for (jdx = 0; jdx < sn_scale_len; jdx++)
                        {
                            if (scale_arr[jdx + idx] != scale->scale[jdx])
                                break;
                        }
                        if (jdx == sn_scale_len)
                        {
                            unique = 0;
                            break;
                        }
                    }
                }
                scale = scale->next;
            }
            /* Add to list of scales */
            if (unique)
            {
                scale_cnt++;
                if (scale_cnt >= sn_first_scale)
                {
                    if ((scale = (snScale *) sn_alloc(sizeof(snScale), "scale data")) == NULL)
                    {
                        printf("Error: Failed to allocate Scale data:\n  %s", strerror(errno));
                        goto gus_error;
                    }
                    jdx = 0;
                    for (idx = 0; idx < sn_scale_len; idx++)
                    {
                        scale->name[idx] = scale_steps[idx];
                        scale->scale[idx] = scale_arr[idx];
                        scale->idx[idx] = jdx;
                        jdx += scale->scale[idx];
                    }
                    scale->name[idx] = '\0';
                    /* Add to scale list */
                    if (anchor->scales == NULL)
                    {
                        anchor->scales = scale;
                        anchor->stail = scale;
                    }
                    else
                    {
                        anchor->stail->next = scale;
                        anchor->stail = scale;
                    }
                    anchor->scalesz++;
                }
            }
        }

    /* - Increment last element, if greater than max_interval, increment */
    /*   previous and reset current to 1                                 */
        for (idx = sn_scale_len - 1; idx >=0; idx--)
        {
            if (idx == 0 && scale_arr[idx] == sn_max_interval)
            {
                done = 1;
                break;
            }
            else if (scale_arr[idx] < sn_max_interval)
            {
                scale_arr[idx]++;
                break;
            }
            else
                scale_arr[idx] = 1;
        }
        if (scale_cnt == sn_max_scales)
            break;
    }
    printf("\n");

    return 0;

gus_error:
    printf("\n");
    if (scale_arr != NULL)
        free(scale_arr);
    if (scale_steps != NULL)
        free(scale_steps);
    return -1;
}

/**
  * \par Function:
  *   parse_staffs
  *
  * \par Description:
  *   Parse the scale example file which contains the following staff parameters:
  *   - Instrument
  *   - Notes
  *   - Start and Duration
  *   - Volume
  *
  * \par
  *   The scale example file is used to produce multiple staff files for different
  *   scales which can then be compared.
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_staffs(void)
{
    int i = 0;
    char line[SN_MAX_LINE];
    FILE *sfd;
    snStaff *staff = NULL;
    snStaffNote *note;
    snHeader *header;

    if ((sfd = fopen(sfile, "r")) == NULL)
    {
        printf("Error: failed to open staff file %s\n  %s\n", sfile, strerror(errno));
        goto pc_error;
    }

    while (!feof(sfd) && !(ferror(sfd)))
    {
        if (fgets(line, SN_MAX_LINE, sfd) == NULL)
        {
            if (feof(sfd))
                break;
            else if (ferror(sfd))
            {
                printf("Error: attempting to read from example file %s\n  %s\n",
                        sfile, strerror(errno));
                goto pc_error;
            }
            continue;
        }
        
        /* Save comments for the csg_staves file */
        if (staff == NULL &&
           (line[0] == '\0' || line[0] == '\n' ||
           (line[0] == '#' && line[1] != ':')))
        {
            if ((header = (snHeader*) sn_alloc(sizeof(snHeader), "header data")) == NULL)
                goto pc_error;
            strncpy(header->line, line, SN_MAX_LINE);
            header->line[SN_MAX_LINE-1] = '\n';
            if (anchor->headers == NULL)
            {
                anchor->headers = header;
                anchor->htail = header;
            }
            else
            {
                anchor->htail->next = header;
                anchor->htail = header;
            }
            continue;
        }

        SKIP_SPACE(line, i, SN_MAX_LINE)
        if (strncmp(&line[i], "STAFF", 4) == 0)
        {
            if (staff != NULL && (staff->instr == NULL || staff->notes == NULL))
            {
                if (staff->name[0] == '\0')
                    printf("Warning: Staff missing instrument or notes: Unknown\n");
                else
                    printf("Warning: Staff missing instrument or notes: %s\n", staff->name);
                goto pc_error;
            }
            if ((staff = (snStaff*) sn_alloc(sizeof(snStaff), "staff data")) == NULL)
                goto pc_error;
            if (strlen(line) > NAME_MAX)
            {
                printf("Error: Staff name too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(staff->name, line);
            if (staff->name[strlen(staff->name) - 1] == '\n')
                staff->name[strlen(staff->name) - 1] = '\0';
            if (anchor->staffs == NULL)
            {
                anchor->staffs = staff;
                anchor->ctail = staff;
            }
            else
            {
                anchor->ctail->next = staff;
                staff->prev = anchor->ctail;
                anchor->ctail = staff;
            }
        }

        else if (strncmp(&line[i], "INSTR", 5) == 0)
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if (strlen(line) > NAME_MAX)
            {
                printf("Error: Instrument name too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(staff->instr, line);
        }

        else if (strncmp(&line[i], "FUND", 4) == 0)
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if ((note = (snStaffNote *) sn_alloc(sizeof(snStaffNote),
                          "staff note data")) == NULL)
                goto pc_error;
            if (strlen(line) > NAME_MAX)
            {
                printf("Error: Staff definition too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(note->line, line);
            /* Put staff notes on list in order defined */
            if (staff->notes == NULL)
            {
                staff->notes = note;
                staff->ntail = note;
            }
            else
            {
                staff->ntail->next = note;
                staff->ntail = note;
            }
        }

        else if (line[0] == '#')
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if ((note = (snStaffNote *) sn_alloc(sizeof(snStaffNote),
                          "staff note data")) == NULL)
                goto pc_error;
            if (line[1] == ':')
                note->flag = MOD_COMMENT;
            else 
                note->flag = SIMP_COMMENT;
            if (strlen(line) > NAME_MAX)
            {
                printf("Error: Staff definition too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(note->line, line);
            /* Put staff notes on list in order defined */
            if (staff->notes == NULL)
            {
                staff->notes = note;
                staff->ntail = note;
            }
            else
            {
                staff->ntail->next = note;
                staff->ntail = note;
            }
        }

        else if (strncmp(&line[i], "NEXT", 4) == 0)
        {
            FIND_SPACE(line, i, SN_MAX_LINE)
            SKIP_SPACE(line, i, SN_MAX_LINE)
            if ((staff->new_scale = sn_getnum(&line[i])) == DBL_ERROR)
            {
                printf("Error: Failed to get next scale value: %s\n", line);
                goto pc_error;
            }
        } 
    }

    fclose(sfd);
    return 0;

pc_error:
    if (sfd != NULL)
        fclose(sfd);
    return -1;
}

/**
  * \par Function:
  *   modify_comment
  *
  * \par Description:
  *   Modify a comment to set it to the real note names of the scale.
  *   For example, this could replace the field ":1" with "A".
  *
  * \par Inputs:
  *   - line: StaffNote line to be parsed
  *   - scale: Scale being written to Staves file
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int modify_comment(char *line, snScale *scale)
{
    int i, ci, idx, jdx = 0;
    char cline[SN_MAX_LINE], numbuf[8];
    double dnum;

    for (idx = 0; idx < SN_MAX_LINE; idx++)
    {
        if (line[idx] == ':' && ('0' <= line[idx+1] && line[idx+1] <= '9'))
        {
            idx++;
            i = 0;
            while ('0' <= line[idx + i] && line[idx + i] <= '9')
            {
                numbuf[i] = line[idx + i];
                i++;
            }
            idx += i - 1;
            numbuf[i] = '\0';
            if ((dnum = sn_getnum(numbuf)) == DBL_ERROR)
                goto mc_error;
            ci = (int) dnum;
            i = (int) scale->idx[ci];
            strcpy(numbuf, anchor->narray[i].name);
            for (i = 0; i < strlen(numbuf); i++)
            {
                cline[jdx] = numbuf[i];
                jdx++;
            }
        }
        else
        {
            cline[jdx] = line[idx];
            jdx++;
        }
    }
    strcpy(line, cline);

    return 0;

mc_error:
    return -1;
}

/**
  * \par Function:
  *   modify_staffnote
  *
  * \par Description:
  *   Parse a note line of a staff example file and modify it for a new staff
  *   file.  The note parsed to determine the desired scale note and that
  *   definition is overlaid.
  *
  *   <br>FUND note start duration volume
  *   - note: <octave> : <scale_index>
  *   - All other fields returned as is
  *
  * \par Inputs:
  *   - line: StaffNote line to be parsed
  *   - scale: Scale being written to Staves file
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int modify_staffnote(char *line, snScale *scale)
{
    int i = 0, ci, idx;
    double dnum;
    char note_name[4], stime[32], gline[SN_MAX_LINE];

    if (strncmp(line, "FUND", 4) != 0)
    {
        printf("Error: line is not note definition: %s\n", line);
        goto pcn_error;
    }

    /* Get note name */
    i = 4;
    SKIP_SPACE(line, i, SN_MAX_LINE)
    strncpy(note_name, &line[i], 3);
    note_name[3] = '\0';
    if (!(note_name[0] >= '0' && note_name[0] <= '9'))
    {
        printf("Error: invalid note octave: %s", line);
        goto pcn_error;
    }
    if (note_name[1] != ':')
    {
        printf("Error: invalid note syntax (required : missing): %s", line);
        goto pcn_error;
    }
    if ((dnum = sn_getnum(&note_name[2])) == DBL_ERROR)
        goto pcn_error;
    idx = (int) dnum;
    ci = (int) scale->idx[idx];
    strcpy(note_name, anchor->narray[ci].name);
    i++;
    for (idx = 0; idx < 3; idx++)
        line[i+idx] = ' ';
    for (idx = 0; idx < strlen(note_name); idx++)
        line[i+idx] = note_name[idx];

    if (sn_group_size > 1)
    {
        FIND_SPACE(line, i, SN_MAX_LINE)
        SKIP_SPACE(line, i, SN_MAX_LINE)
        idx = 0;
        memset(stime, 0, 32);
        while (line[i+idx] != ' ' && line[i+idx] != '\t')
        {
            stime[idx] = line[i+idx];
            idx++;
            if (idx > 30)
            {
                printf("Error: Start time invalid:\n  %s\n", line);
                goto pcn_error;
            }
        }
        strcpy(gline, &line[i+idx]);
        if ((dnum = sn_getnum(stime)) == DBL_ERROR)
            goto pcn_error;
        dnum += sn_group_interval;
        snprintf(&line[i], SN_MAX_LINE, "%.2f%s", dnum, gline);
    }

    return 0;

pcn_error:
    return -1;
}

/**
  * \par Function:
  *   create_staff_file
  *
  * \par Description:
  *   Using the example file data create a csg_staves file for every scale
  *   generated by the sn_get_unique_scales function.
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int create_staff_file()
{
    int idx, i, ci, gsz, loopcnt = 0;
    char cbuf[SN_MAX_LINE], fbuf[SN_MAX_FN];
    snHeader *header;
    snStaff *staff;
    snStaffNote *stnote;
    snScale *scale;
    FILE *vfd = NULL;

    scale = anchor->scales;
    gsz = sn_group_size;
    printf("Create staff files: ");
    while (scale != NULL)
    {
        if ((loopcnt & 0x7f) == 0)
            printf(".");
        loopcnt++;
        if (gsz >= sn_group_size)
        {
            gsz = 1;
            sn_group_interval = 0.0;
            strncpy(fbuf, vfile, SN_MAX_FN - sn_scale_len - 2);
            i = strlen(vfile);
            fbuf[i] = '.';
            i++;
            for (idx = 0; idx < sn_scale_len; idx++)
            {
                ci = (int ) scale->scale[idx];
                fbuf[i + idx] = sn_intervals[ci];
            }
            if ((vfd = fopen(fbuf, "w")) == NULL)
            {
                printf("Error: failed to open staff file %s\n  %s\n", vfile, strerror(errno));
                goto ccf_error;
            }

            if (fputs(CSG_HEADER, vfd) != 0)
            {
                CFILE_ERROR(vfd, "staff definition", ccf_error)
            }
            header = anchor->headers;
            while (header != NULL)
            {
                if (fputs(header->line, vfd) != 0)
                {
                    CFILE_ERROR(vfd, "header comment", ccf_error)
                }
                header = header->next;
            }
        }
        else
            gsz++;

        staff = anchor->staffs;
        while (staff != NULL)
        {
            snprintf(cbuf, SN_MAX_LINE, "\n%s_%s\n", staff->name, scale->name);
            if (fputs(cbuf, vfd) != 0)
            {
                CFILE_ERROR(vfd, "staff definition", ccf_error)
            }
            if (fputs(staff->instr, vfd) != 0)
            {
                CFILE_ERROR(vfd, "instrument definition", ccf_error)
            }
            stnote = staff->notes;
            while (stnote != NULL)
            {
                strcpy(cbuf, stnote->line);
                if (stnote->flag == 0 && modify_staffnote(cbuf, scale) != 0)
                {
                    CFILE_ERROR(vfd, "note definition", ccf_error)
                }
                else if (stnote->flag == MOD_COMMENT && modify_comment(cbuf, scale) != 0)
                {
                    CFILE_ERROR(vfd, "comment modification", ccf_error)
                }
                if (fputs(cbuf, vfd) != 0)
                {
                    CFILE_ERROR(vfd, "note definition", ccf_error)
                }
                stnote = stnote->next;
            }
            sn_group_interval += staff->new_scale;
            staff = staff->next;
        }
        scale = scale->next;
        if (gsz >= sn_group_size)
        {
            fclose(vfd);
            vfd = NULL;
        }
    }
    printf("\n");

    if (vfd != NULL)
        fclose(vfd);
    return 0;

ccf_error:
    printf("\n");
    if (vfd != NULL)
        fclose(vfd);
    return -1;
}

/**
  * \par Function:
  *   add_exclude
  *
  * \par Description:
  *   Utility function to add exclude patterns to list.
  *
  * \par Inputs:
  *   - pat: Pattern
  *   - type: Pattern type
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

#define SN_PAT_CHAR   1
#define SN_PAT_NUM    2

int add_exclude(char *pat)
{
    int i;
    snPattern *tpat;

    i = strlen(pat);
    if ((i + 1) > MAX_SCALE_LEN)
    {
        printf("DEBUG: Pattern too long '%s'\n", pat);
        goto ae_error;
    }
    if ((tpat = (snPattern *) sn_alloc(sizeof(snPattern), "exclude pattern")) == NULL)
        goto ae_error;
    tpat->len = i;

    strcpy(tpat->pat, pat);
    if (anchor->xpat == NULL)
    {
        anchor->xpat = tpat;
    }
    else
    {
        tpat->next = anchor->xpat;
        anchor->xpat = tpat;
    }

    return 0;

ae_error:
    if (tpat != NULL)
        free(tpat);
    return -1;
}

/**
  * \par Function:
  *   main
  *
  * \par Description:
  *   The command line arguments are checked here.  Then the snMain anchor is
  *   initializaed.  If this is successful, then the scales are calculated and
  *   the staff file is created.
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - 1 = Error
  */

int main (int argc, char *argv[])
{
    int opt, idx;
    int debug = 0, skip_staffs = 0;
    char *ept;
    snNote *note;

    printf("\nStarting CSound Scale Note Generator\n");

    if ((anchor = (snMain *) sn_alloc(sizeof(snMain), "scale anchor")) == NULL)
        return 1;

    strcpy(vfile, DFLT_STAFF_FILE);
    strcpy(nfile, DFLT_NOTE_FILE);
    strcpy(sfile, DFLT_SCALE_FILE);
    if (argc > 1)
    {
        // Parse command line arguments
        while ((opt = getopt(argc, argv, "d:l:n:v:f:g:i:km:s:x:")) != -1)
        {
            switch (opt)
            {
              case 'k':
                  skip_staffs = 1;
                  break;
              case 'd':
                  debug = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || debug < 0) 
                  {
                      printf("Error: invalid debug code, ignored: %s\n", optarg);
                      debug = 0;
                  }
                  break;
              case 's':
                  strncpy(sfile, optarg, SN_MAX_FN);
                  sfile[SN_MAX_FN - 1] = '\0';
                  break;
              case 'n':
                  strncpy(nfile, optarg, SN_MAX_FN);
                  nfile[SN_MAX_FN - 1] = '\0';
                  break;
              case 'v':
                  strncpy(vfile, optarg, SN_MAX_FN);
                  vfile[SN_MAX_FN - 1] = '\0';
                  break;
              case 'f':
                  sn_first_scale = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || sn_first_scale < 0 || sn_first_scale > MAX_SCALES) 
                  {
                      printf("Error: invalid first scale: %s\n", optarg);
                      goto main_err;
                  }
                  break;
              case 'g':
                  sn_group_size = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || sn_group_size < 0 || sn_group_size > 512) 
                  {
                      printf("Error: invalid group size: %s\n", optarg);
                      goto main_err;
                  }
                  break;
              case 'i':
                  sn_max_interval = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || sn_max_interval < 0 || sn_max_interval > MAX_INTERVAL) 
                  {
                      printf("Error: invalid maximum interval: %s\n", optarg);
                      goto main_err;
                  }
                  break;
              case 'm':
                  sn_max_scales = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || sn_max_scales < 0 || sn_max_scales > MAX_SCALES) 
                  {
                      printf("Error: invalid max scales: %s\n", optarg);
                      goto main_err;
                  }
                  break;
              case 'l':
                  sn_scale_len = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || sn_scale_len < 0 || sn_scale_len > 512) 
                  {
                      printf("Error: invalid scale length: %s\n", optarg);
                      goto main_err;
                  }
                  if (sn_scale_len < 0 || sn_scale_len > MAX_SCALE_LEN)
                  {
                      printf("Error: invalid scale length: %s\n", optarg);
                      goto main_err;
                  }
                  break;
              case 'x':
                  if (add_exclude(optarg) != 0)
                      goto main_err;
                  break;
          /* - exclude pattern: may be entered multiple times
           *   (ie. -x"hhh" -x"www" -x"MM")
           */
              default:
                  printf("\ncsnd_sn Version %s\n", SN_VER);
                  printf("\ncsnd_sn [arguments]:\n");
                  printf("  -n: note_file: Name of note file\n");
                  printf("      Default: %s\n", DFLT_NOTE_FILE);
                  printf("  -s: scale_file: Name of scale file\n");
                  printf("      Default: %s\n", DFLT_SCALE_FILE);
                  printf("  -v: staves_file: Name of staves file\n");
                  printf("      Default: %s\n", DFLT_STAFF_FILE);
                  printf("  -l: number: Length of scale (excluding octave)\n");
                  printf("      Range: 1 - %d, Default: %d\n",
                            MAX_SCALE_LEN, DFLT_SCALE_LEN);
                  printf("  -i: number: Maximum interval\n");
                  printf("      Default: %d (major 3rd), maximum: %d (fourteenth)\n",
                            DFLT_INTERVAL, MAX_INTERVAL);
                  printf("  -f: number: First scale to generate\n");
                  printf("      Default: 1, maximum: %d\n", MAX_SCALES);
                  printf("  -m: number: Maximum number of scales to generate\n");
                  printf("      Default: all, maximum : %d\n", MAX_SCALES);
                  printf("  -x: string: Step pattern to exclude may be entered multiple times\n");
                  printf("      Examples: -x\"hhh\" -x\"whw\"\n");
                  printf("  -g: number: Number of scales to group in a staves file\n");
                  printf("      Default: 1\n");
                  printf("  -k: Skip staff file generation\n");
                  printf("  -d: debug code: Note = 1, Scales = 2, Staff = 4\n");
                  printf("      Values can be ORed for multiple printouts\n");
                  printf("\n");
                  printf("  NOTE: Scale names are the list of intervals where:\n");
                  printf("    h = half tone, w = whole tone, m = minor 3rd, M = major 3rd, f = fourth,\n");
                  printf("    d = diminished fifth, F = fifth, a = augmented fifth, s = sixth,\n");
                  printf("    A = augmented sixth, S = seventh, j = major seventh, e = eighth,\n");
                  printf("    n = diminished ninth, N = ninth, t = diminished tenth, T = tenth,\n");
                  printf("    v = diminished eleventh, V = eleventh, l = diminished twelfth, L = twelfth,\n");
                  printf("    r = diminished thirteenth, R = thirteenth, o = diminished fourteenth, O = fourteenth\n");
                  printf("    Example: csg_staves.whMhmww\n");
                  printf("\n");
                  return 0;
                  break;
            }
        }
    }

    if (sn_max_scales < 0xfffffff)
        sn_max_scales += sn_first_scale;

    /* Parse the notes file */
    if (parse_notes(nfile) != 0)
        return 1;
    idx = anchor->notesz * sizeof(snNoteArray);
    if ((anchor->narray = (snNoteArray *) sn_alloc(idx, "staff note data")) == NULL)
        return 1;
    note = anchor->notes;
    idx = 0;
    while (note != NULL && idx < anchor->notesz)
    {
        strcpy(anchor->narray[idx].name, note->name);
        anchor->narray[idx].note = note;
        idx++;
        note = note->next;
    }
    if (debug & DEBUG_NOTE)
        sn_print_data(TYPE_NOTE);

    /* Get unique scales for the tuning */
    if (sn_get_unique_scales() != 0)
        return 1;
    if (debug & DEBUG_SCALE)
        sn_print_data(TYPE_SCALE);

    if (!skip_staffs)
    {
        /* Get the example file to play scales */
        if (parse_staffs() != 0)
            return 1;
        if (debug & DEBUG_STAFF)
            sn_print_data(TYPE_STAFF);

        /* Generate csg_staves file(s) */
        create_staff_file();
    }


    printf("Completed CSound Scale Note Generator creating %d scales\n\n", anchor->scalesz);
    return 0;

main_err:
    return -1;
}


