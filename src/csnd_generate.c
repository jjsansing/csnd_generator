/**
 * /file csnd_generate.c
 * <h3> CSound Score Generator Program</h3>
 *
 ************************************************************************
 * <hr><p>
 * Copyright (C) 2020 Jim Sansing
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 * <hr><p>
 ************************************************************************
 * 
 * Input Data
 * - Score filename
 * - Template filename
 * - Note definition filename
 * - Harmonic variables
 * 
 * Output Data
 * - <filename>.sco
 * - <filename>.wav
 * 
 * Functions
 * - Parse command line
 * - Parse template file
 * - Parse note definition file
 * - Create score
 *   - Add fundamental note
 *   - Add harmonics
 *     - Modify harmonics over time
 * -?? Run CSound to produce wav file (probably done in script)
 */

#include "csnd_generate.h"

#define CSG_VER "1.0"
#define CSG_HEADER ";This score was generated by the CSound Generator 1.0\n\n"
#define TEMPO_DIFF 1.0
double tempo_diff = TEMPO_DIFF;

char tfile[CSG_MAX_FN];  // Template filename
char vfile[CSG_MAX_FN];  // Staves filename
char sfile[CSG_MAX_FN];  // Score filename

int basenoteidx = 0;

csgScore *score;


/**
  * \par Function:
  *   csg_alloc
  *
  * \par Description:
  *   This is a utility function to allocate data structures.  It initializes
  *   the space to 0s.
  *
  * \par Inputs:
  *   - datasz: Amount of memory to be allocated
  *   - dmsg: Data type being allocated
  *
  * \par Outputs:
  *   - char pointer
  *     - NULL = Error
  */

char * csg_alloc(int datasz, char *dmsg)
{
    char *datastruct;

    if ((datastruct = (char *) malloc(datasz)) == NULL)
    {
        printf("Error: could not allocate %s\n  %s\n", dmsg, strerror(errno));
        return NULL;
    }
    memset(datastruct, 0, datasz);
    return datastruct;
}

/**
  * \par Function:
  *   csg_print_data;
  *
  * \par Description:
  *   This is a utility function to print data.
  *
  * \par Inputs:
  *   - datatypes: Bit flag to indicate datatypes
  *
  * \par Outputs:
  *   - None
  */

#define TYPE_NOTE       0x0001
#define TYPE_NOTEF      0x0002
#define TYPE_INSTR      0x0004
#define TYPE_FUNC       0x0008
#define TYPE_STAFF      0x0010
#define TYPE_SCORE      0x0020

void csg_print_data(int datatypes)
{
    int i;
//  csgNote *note;
    csgInstrument *instr;
    csgTone *tone;
    csgSimpTone *stone;
    csgVowelTone *vtone;
    csgSNDTone *sndtone;
    csgStaff *staff;
    csgStaffNote *chnote;
    csgFunction *func;

    if (datatypes & TYPE_NOTE)
    {
        for (i=0; i < score->notesz; i++)
        {
            printf("Note name '%s' (%s)  Frequency %.4f\n", 
                    score->narray[i].note->name, score->narray[i].name,
                    score->narray[i].note->freq);
        }
    }

    if (datatypes & TYPE_NOTEF)
    {
        for (i=0; i < score->notesz; i++)
        {
            printf("Note name '%s' (%.4f)  Frequency %.4f\n", 
                    score->nfrqarr[i].note->name, score->nfrqarr[i].freq,
                    score->nfrqarr[i].note->freq);
        }
    }

    if (datatypes & TYPE_FUNC)
    {
        func = score->functions;
        while (func != NULL)
        {
            printf("Function: '%s'\n", func->parms);
            func = func->next;
        }
    }

    if (datatypes & TYPE_INSTR)
    {
        instr = score->instruments;
        while (instr != NULL)
        {
            printf("Instrument name: '%s'\n", instr->name);
            tone = instr->tones;
            while (tone != NULL)
            {
                printf("Generic Tone: %p\n", tone);
                printf("Tone: Start %.4f Duration %.4f Volume %.4f, Frequency %.4f\n",
                        tone->start, tone->durat,
                        tone->vol, tone->freq);
                printf("      Parms %s\n", tone->parms);
                tone = tone->next;
            }
            stone = instr->stones;
            while (stone != NULL)
            {
                printf("Simple Tone: %p\n", stone);
                printf("Tone: Start %.4f Duration %.4f Volume %d, Frequency %.4f\n",
                        stone->start, stone->durat, stone->vol, stone->freq);
                printf("      Remaining Parameters: %s",
                        stone->parms);
                stone = stone->next;
            }
            vtone = instr->vtones;
            while (vtone != NULL)
            {
                printf("Vowel Tone: %p\n", vtone);
                printf("Tone: Start %.4f Duration %.4f Volume %d, Frequency %.4f\n",
                        vtone->start, vtone->durat, vtone->vol, vtone->freq);
                printf("      Tilt %d Vibrate Depth %.4f Vibrate Amount %.4f\n",
                        vtone->tilt, vtone->vibdepth, vtone->vibamt);
                vtone = vtone->next;
            }
            sndtone = instr->sndtones;
            while (sndtone != NULL)
            {
                printf("Tone: %p\n", sndtone);
                printf("Tone: Start %.4f Duration %.4f Volume %d, Pitch %.4f\n",
                        sndtone->start, sndtone->durat, sndtone->vol, sndtone->pitch);
                sndtone = sndtone->next;
            }
            instr = instr->next;
        }
    }

    if (datatypes & TYPE_STAFF)
    {
        staff = score->staffs;
        while (staff != NULL)
        {
            printf("Staff name: '%s'\n", staff->name);
            printf("Instrument: '%s'\n", staff->instr->name);
            printf("     Repeat %d Period %.4f Vol_change %d Period_change %.4f\n",
                    staff->repeat, staff->period, staff->volchange, staff->pdchange);
            chnote = staff->notes;
            while (chnote != NULL)
            {
                printf("Staff Note: Start %.4f Duration %.4f Volume %d\n",
                        chnote->start,
                        chnote->durat, chnote->vol);
                chnote = chnote->next;
            }
            staff = staff->next;
        }
    }

    if (datatypes & TYPE_SCORE)
    {
        printf("Score: Note size %d Notes %p Note Array %p\n",
                score->notesz, score->notes, score->narray);
        printf("Score: Instruments %p Functions %p Staffs %p\n",
                score->instruments, score->functions, score->staffs);
    }

    return;
}

/**
  * \par Function:
  *   csg_getnum
  *
  * \par Description:
  *   This is a utility function to parse numeric values.  The values can
  *   be simple integers or decimals in any format and precision.
  *
  * \par Inputs:
  *   - line: Line to be parsed, starting at number to be parsed
  *
  * \par Outputs:
  *   - double: Result
  *     - DBL_ERROR = -99999.999 returned if error
  */

double csg_getnum(char *line)
{
    int i= 0, j = 0, found = 0;
    double tnum;
    char nbuf[32], *ept;

    memset(nbuf, 0, 32);

    do {
        if (line[i] == ' ' || line[i] == '\t' || line[i] == '\0' || line[i] == '\n')
        {
            if (j > 0)
            {
                nbuf[j] = '\0';
                tnum = strtod(nbuf, &ept);
                found = 1;
                if (*ept != '\0')
                {
                    printf("Error: invalid numeric value: '%s'\n  %s\n", nbuf, line);
                    return DBL_ERROR;
                }
            }
            else
            {
                printf("Error: numeric value not found:\n  %s\n", line);
                return DBL_ERROR;
            }
        }
        nbuf[j++] = line[i++];
    } while (!found);
    
    return tnum;
}

/**
  * \par Function:
  *   csg_sortnotes
  *
  * \par Description:
  *   This is a utility function to assist sorting notes by frequency.
  *
  * \par Inputs:
  *   - note1: First note to compare
  *   - note2: Second note to compare
  *
  * \par Outputs:
  *   - int: 
  *     - <0 = note2 is greater than note1
  *     - 0 = note2 is equal to note1
  *     - >0 = note2 is less than note1
  */

int csg_sortnotes(const void *note1, const void *note2)
{
    int i;
    double d;
    csgNoteFreqArray *n1 = (csgNoteFreqArray *) note1;
    csgNoteFreqArray *n2 = (csgNoteFreqArray *) note2;

    d = n1[0].freq - n2[0].freq;
    if (d < 0.0)
        i = -1;
    else if (d > 0.0)
        i = 1;
    else
        i = 0;

    return(i);
}

/**
  * \par Function:
  *   csg_getnote
  *
  * \par Description:
  *   This is a utility function to search the sorted note array for a
  *   specific note.
  *
  * \par Inputs:
  *   - note_name: The note to be found
  *   - min: Index of the lowest array portion to search
  *   - max: Index of the highest array portion to search
  *
  * \par Outputs:
  *   - note: csgNote pointer
  *     - NULL = Error
  */

csgNote *csg_getnote(char *note_name, int min, int max)
{
    int mid;

    if (max >= min)
    {
        mid = min + ((max - min) >> 1);
        if (strcmp(score->narray[mid].name, note_name) == 0)
            return score->narray[mid].note;

        if (strcmp(score->narray[mid].name, note_name) > 0)
            return csg_getnote(note_name, min, mid - 1);

        return csg_getnote(note_name, mid + 1, max);
    }

    printf("Error: Note was not found: '%s'\n", note_name);
    return NULL;
}

/**
  * \par Function:
  *   csg_getvowel
  *
  * \par Description:
  *   This is a utility function to search the sorted vowel array for a
  *   specific vowel.
  *
  * \par Inputs:
  *   - vowel_name: The vowel to be found
  *   - min: Index of the lowest array portion to search
  *   - max: Index of the highest array portion to search
  *
  * \par Outputs:
  *   - vowel: csgVowel pointer
  *     - NULL = Error
  */

csgVowel *csg_getvowel(char *vowel_name, int min, int max)
{
    int mid;

    if (score->varray == NULL)
        return NULL;

    if (max >= min)
    {
        mid = min + ((max - min) >> 1);
        if (strcmp(score->varray[mid].name, vowel_name) == 0)
            return score->varray[mid].vowel;

        if (strcmp(score->varray[mid].name, vowel_name) > 0)
            return csg_getvowel(vowel_name, min, mid - 1);

        return csg_getvowel(vowel_name, mid + 1, max);
    }

    printf("Error: vowel was not found: '%s'\n", vowel_name);
    return NULL;
}

/**
  * \par Function:
  *   parse_gen_tone
  *
  * \par Description:
  *   Parse simple tones on a single line of a template file and add them to a
  *   csgTone struct.  It is assumed that the CSound score definitions
  *   are understood and they will not be explained.  The format of the
  *   tone line is as follows:
  * <code>
  *              p3  p4    p5      p6    p7    p8    p9    p10
  * INSTR START  DUR AMP   FREQ    WAVE  ATT   DEC   SUS   REL
  * </code>
  * \par Inputs:
  *   - line: Tone line to be parsed
  *
  * \par Outputs:
  *   - csgTone struct with parsed data
  *     - NULL = Error
  */

csgTone *parse_gen_tone(char *line)
{
    int i = 0, idx;
    csgTone *tone = NULL;

    if ((tone = (csgTone *) csg_alloc(sizeof(csgTone), "tone data")) == NULL)
        goto pgt_error;

    /* Get start time */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE ||
        (tone->start = csg_getnum(&line[i])) == DBL_ERROR)
        goto pgt_error;

    /* Get duration */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->durat = csg_getnum(&line[i])) == DBL_ERROR)
        goto pgt_error;

    /* Get volume */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE ||
        (tone->vol = csg_getnum(&line[i])) == DBL_ERROR)
        goto pgt_error;

    /* Get frequency */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->freq = csg_getnum(&line[i])) == DBL_ERROR)
        goto pgt_error;

    /* Get wave function */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    strcpy(tone->parms, &line[i]);
    idx = strlen(tone->parms) - 1;
    if (tone->parms[idx] == '\n')
        tone->parms[idx] = ' ';

    return tone;

pgt_error:
    if (tone != NULL)
    {
        free(tone);
        printf("Error getting tone in line: '%s'\n", line);
    }
    return NULL;
}

/**
  * \par Function:
  *   parse_simp_tone
  *
  * \par Description:
  *   Parse simple tones on a single line of a template file and add them to a
  *   csgSimpTone struct.  It is assumed that the CSound score definitions
  *   are understood and they will not be explained.  The format of the
  *   tone line is as follows:
  * <code>
  *              p3  p4    p5      p6    p7    p8    p9    p10
  * INSTR START  DUR AMP   FREQ    WAVE  ATT   DEC   SUS   REL
  * </code>
  * \par Inputs:
  *   - line: Tone line to be parsed
  *
  * \par Outputs:
  *   - csgSimpTone struct with parsed data
  *     - NULL = Error
  */

csgSimpTone *parse_simp_tone(char *line)
{
    int i = 0, len;
    double dnum;
    csgSimpTone *tone = NULL;

    if ((tone = (csgSimpTone *) csg_alloc(sizeof(csgSimpTone), "tone data")) == NULL)
        goto pst_error;

    /* Get start time */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE ||
        (tone->start = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get duration */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->durat = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get volume */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;
    tone->vol = (int) dnum;

    /* Get frequency */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->freq = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get remaining parameters */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    len = strlen(&line[i]) + 2;
    if ((tone->parms = (char *) csg_alloc(len, "tone parameters")) == NULL)
        goto pst_error;
    strcpy(tone->parms, &line[i]);


    return tone;

pst_error:
    if (tone != NULL)
    {
        free(tone);
        printf("Error getting tone in line: '%s'\n", line);
    }
    return NULL;
}

/**
  * \par Function:
  *   parse_vowel_tone
  *
  * \par Description:
  *   Parse vowel tones on a single line of a template file and add them to a
  *   csgVowelTone struct.  It is assumed that the CSound score definitions
  *   are understood and they will not be explained.  The format of the
  *   tone line is as follows:
  * <code>
  *              p3  p4    p5     p6      p7    p8         p9
  * INSTR START  DUR AMP   FREQ   (vowel) TILT  VIB_DEPTH  VIB_AMT
  * </code>
  * \par Inputs:
  *   - line: Tone line to be parsed
  *
  * \par Outputs:
  *   - csgVowelTone struct with parsed data
  *     - NULL = Error
  */

csgVowelTone *parse_vowel_tone(char *line)
{
    int i = 0;
    double dnum;
    csgVowelTone *tone = NULL;

    if ((tone = (csgVowelTone *) csg_alloc(sizeof(csgVowelTone), "tone data")) == NULL)
        goto pst_error;

    /* Get start time */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE ||
        (tone->start = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get duration */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->durat = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get volume */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;
    tone->vol = (int) dnum;

    /* Get frequency */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->freq = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get tilt */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;
    tone->tilt = (int) dnum;

    /* Get vibration depth */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->vibdepth = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    /* Get sustain */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->vibamt = csg_getnum(&line[i])) == DBL_ERROR)
        goto pst_error;

    return tone;

pst_error:
    if (tone != NULL)
    {
        free(tone);
        printf("Error getting tone in line: '%s'\n", line);
    }
    return NULL;
}

/**
  * \par Function:
  *   parse_SND_tone
  *
  * \par Description:
  *   Parse tones from sound files.  The format of the tone line is as follows:
  * <code>
  *              p3  p4    p5
  * INSTR START  DUR AMP   PITCH
  * </code>
  *
  * NOTE: The pitch is relative to the original sound file, where 0.5 is an
  * octave below and 2.0 is an octave above.  This is multiplied times the 
  * staff note frequency, so that should be a number close to 1.0.  In most
  * cases, pitch should be 1.0 in the csg_tmplt file.
  *
  * \par Inputs:
  *   - line: Tone line to be parsed
  *
  * \par Outputs:
  *   - csgSNDTone struct with parsed data
  *     - NULL = Error
  */

csgSNDTone *parse_SND_tone(char *line)
{
    int i = 0;
    double dnum;
    csgSNDTone *tone = NULL;

    if ((tone = (csgSNDTone *) csg_alloc(sizeof(csgSNDTone), "tone data")) == NULL)
        goto psndt_error;

    /* Get start time */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->start = csg_getnum(&line[i])) == DBL_ERROR)
        goto psndt_error;

    /* Get duration */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->durat = csg_getnum(&line[i])) == DBL_ERROR)
        goto psndt_error;

    /* Get volume */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto psndt_error;
    tone->vol = (int) dnum;

    /* Get pitch */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (tone->pitch = csg_getnum(&line[i])) == DBL_ERROR)
        goto psndt_error;

    return tone;

psndt_error:
    if (tone != NULL)
    {
        free(tone);
        printf("Error getting tone in line: '%s'\n", line);
    }
    return NULL;
}

/**
  * \par Function:
  *   parse_tone
  *
  * \par Description:
  *   Parse tones on a single line of a note file and add them to a
  *   csgInstrument struct.  There are multiple formats for tones and
  *   each is handled separately.
  *
  * \par Inputs:
  *   - line: Tone line to be parsed
  *   - instr: Instrument to which tones belong
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_tone(char *line, csgInstrument *instr)
{
    int i = 0, fixed = 0;
    csgTone *tone = NULL;
    csgSimpTone *stone = NULL;
    csgVowelTone *vtone = NULL;
    csgSNDTone *sndtone = NULL;

    /* Get tone type */
    SKIP_SPACE(line, i, CSG_MAX_LINE)

    if (strncmp(line, "TONE", 4) == 0 || strncmp(line, "TFIXED", 6) == 0)
    {
        if (strncmp(line, "TONE", 4) == 0)
            i += 5;
        else
        {
            fixed = 1;
            i += 7;
        }
        if ((tone = parse_gen_tone(&line[i])) == NULL)
            goto pt_error;
        if (fixed)
            tone->flag |= TONE_FIXED;
        if (instr->tones == NULL)
        {
            instr->tones = tone;
            instr->ttail = tone;
        }
        else
        {
            instr->ttail->next = tone;
            instr->ttail = tone;
        }
    }

    else if (strncmp(line, "SIMP", 4) == 0 || strncmp(line, "FIXED", 5) == 0)
    {
        if (strncmp(line, "SIMP", 4) == 0)
            i += 5;
        else
        {
            fixed = 1;
            i += 6;
        }
        if ((stone = parse_simp_tone(&line[i])) == NULL)
            goto pt_error;
        if (fixed)
            stone->flag |= TONE_FIXED;
        if (instr->stones == NULL)
        {
            instr->stones = stone;
            instr->sttail = stone;
        }
        else
        {
            instr->sttail->next = stone;
            instr->sttail = stone;
        }
    }

    else if (strncmp(line, "VOICE", 5) == 0)
    {
        i += 6;
        if ((vtone = parse_vowel_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->vtones == NULL)
        {
            instr->vtones = vtone;
            instr->vttail = vtone;
        }
        else
        {
            instr->vttail->next = vtone;
            instr->vttail = vtone;
        }
    }

    else if (strncmp(line, "FM", 2) == 0)
    {
        i += 3;
        if ((stone = parse_simp_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->stones == NULL)
        {
            instr->stones = stone;
            instr->sttail = stone;
        }
        else
        {
            instr->sttail->next = stone;
            instr->sttail = stone;
        }
    }

    else if (strncmp(line, "AM", 2) == 0)
    {
        i += 3;
        if ((stone = parse_simp_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->stones == NULL)
        {
            instr->stones = stone;
            instr->sttail = stone;
        }
        else
        {
            instr->sttail->next = stone;
            instr->sttail = stone;
        }
    }

    /* TODO: Add more wave shaping
     * - In csg.orc, use globals to create complex waveforms and then
     *   run them through the wave shaper
     */
    else if (strncmp(line, "WS1", 3) == 0)
    {
        i += 4;
        if ((stone = parse_simp_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->stones == NULL)
        {
            instr->stones = stone;
            instr->sttail = stone;
        }
        else
        {
            instr->sttail->next = stone;
            instr->sttail = stone;
        }
    }

    else if (strncmp(line, "WS2", 3) == 0)
    {
        i += 4;
        if ((stone = parse_simp_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->stones == NULL)
        {
            instr->stones = stone;
            instr->sttail = stone;
        }
        else
        {
            instr->sttail->next = stone;
            instr->sttail = stone;
        }
    }

    else if (strncmp(line, "SND", 3) == 0)
    {
        i += 4;
        if ((sndtone = parse_SND_tone(&line[i])) == NULL)
            goto pt_error;
        if (instr->sndtones == NULL)
        {
            instr->sndtones = sndtone;
            instr->sndttail = sndtone;
        }
        else
        {
            instr->sndttail->next = sndtone;
            instr->sndttail = sndtone;
        }
    }

    return 0;

pt_error:
    return -1;
}

/**
  * \par Function:
  *   add_sorted_note
  *
  * \par Description:
  *   This is a utility function to add a csgNote struct to a sorted list.
  *
  * \par Inputs:
  *   - note: First struct in list
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *     - >0 = Duplicate note found
  */

int add_sorted_note(csgNote *note)
{
    csgNote *tn = score->notes;

    if (strcmp(note->name, tn->name) < 0)
    {
        note->next = score->notes;
        score->notes = note;
        return 0;
    }

    while (tn->next != NULL && strcmp(note->name, tn->next->name) > 0)
        tn = tn->next;
    if (tn->next != NULL && strcmp(note->name, tn->next->name) == 0)
    {
        if (tn->next != NULL && note->freq != tn->next->freq)
            printf("Warning: Duplicate note with different frequency: %s %.4f\n",
                    note->name, note->freq);
        return 1;
    }
    note->next = tn->next;
    tn->next = note;

    return 0;
}

/**
  * \par Function:
  *   parse_notes
  *
  * \par Description:
  *   Parse the notes file which contains note definitions.  The file only
  *   maps note names to frequencies for easy reference.  Since multiple note
  *   files are allowed, if there is a duplicate note name, it is ignored,
  *   although if the frequency is different from the existing frequency, a
  *   warning is issued.
  *
  *   The format of the note file is as follows:
  *
  *   <br>Comments are indicated by preceeding a line with '#', and blank lines
  *   are permitted.
  *   <br>NOTE name frequency
  *   - name: <octave> <note> <modifier> 
  *     - octave = 0 (A = 27.5 Hz) - 9 (A = 14080 Hz)
  *     - note: A - Z and a - z case sensitive
  *     - modifiers: 0 - 9, A - Z, and a - z case sensitive
  *   - frequency: double
  *
  * \par Inputs:
  *   - notefn: Name of note file to parse
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_notes(char *notefn)
{
    int i;
    char line[CSG_MAX_LINE];
    FILE *nfd;
    csgNote *note = NULL;

    if ((nfd = fopen(notefn, "r")) == NULL)
    {
        printf("Error: failed to open note file %s\n  %s\n", notefn, strerror(errno));
        goto pn_error;
    }

    while (!feof(nfd) && !(ferror(nfd)))
    {
        if (fgets(line, CSG_MAX_LINE, nfd) == NULL)
        {
            if (feof(nfd))
                break;
            else if (ferror(nfd))
            {
                printf("Error: attempting to read from note file %s\n  %s\n",
                        notefn, strerror(errno));
                goto pn_error;
            }
            continue;
        }
        /* Check for blank lines and comments */
        for (i=0; i < CSG_MAX_LINE; i++)
        {
            if (line[i] == '\0' || line[i] == '\n' || line[i] == '#')
            {
                i = CSG_MAX_LINE;
                break;
            }
            else if (line[i] != ' ' || line[i] == '\t')
                break;
        }
        if (i >= CSG_MAX_LINE)
            continue;
        if (strncmp(&line[i], "NOTE", 4) == 0)
        {
            if ((note = (csgNote *) csg_alloc(sizeof(csgNote), "note data")) == NULL)
                goto pn_error;
            i += 5;
            strncpy(note->name, &line[i], 3);
            if (!( (note->name[2] >= '0' && note->name[2] <= '9') ||
                   (note->name[2] >= 'a' && note->name[2] <= 'z') ||
                   (note->name[2] >= 'A' && note->name[2] <= 'Z') ))
                note->name[2] = ' ';
            /* Find end of note name and start of frequency */
            FIND_SPACE(line, i, CSG_MAX_LINE)
            SKIP_SPACE(line, i, CSG_MAX_LINE)
            if (i >= CSG_MAX_LINE || 
                (note->freq = csg_getnum(&line[i])) == DBL_ERROR)
                goto pn_error;
            if (score->notes == NULL)
            {
                score->notes = note;
                score->notesz++;
            }
            else
            {
                if (add_sorted_note(note) == 0)
                    score->notesz++;
            }
        }
    }

    fclose(nfd);
    return 0;

pn_error:
    if (nfd != NULL)
    {
        printf("Error getting note in line: '%s'\n", line);
        fclose(nfd);
    }
    return -1;
}

/**
  * \par Function:
  *   add_sorted_vowel
  *
  * \par Description:
  *   This is a utility function to add a csgVowel struct to a sorted list.
  *
  * \par Inputs:
  *   - vowel: First struct in list
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *     - >0 = Duplicate found
  */

int add_sorted_vowel(csgVowel *vowel)
{
    csgVowel *tv = score->vowels;

    if (strcmp(vowel->name, tv->name) < 0)
    {
        vowel->next = score->vowels;
        score->vowels = vowel;
        return 0;
    }

    while (tv->next != NULL && strcmp(vowel->name, tv->next->name) > 0)
        tv = tv->next;
    if (tv->next != NULL && strcmp(vowel->name, tv->next->name) == 0)
    {
        return 1;
    }
    vowel->next = tv->next;
    tv->next = vowel;

    return 0;
}

/**
  * \par Function:
  *   parse_vowel
  *
  * \par Description:
  *   Parse the vowel definition.  If there is a duplicate vowel name, it is ignored.
  *
  *   The format of the vowel file is as follows:
  *
  *   <br>VOWEL id name 
  *   - id: CSound id (0 - 64)
  *   - name: freeform of 7 characters or less
  *
  * \par Inputs:
  *   - line: The VOWEL definition in a csg_tmplt file
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_vowel(char *line)
{
    int i = 0;
    double dnum;
    csgVowel *vowel = NULL;

    if ((vowel = (csgVowel *) csg_alloc(sizeof(csgVowel), "vowel data")) == NULL)
        goto pv_error;
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pv_error;
    vowel->id = (int) dnum;
    /* Find vowel name */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (strlen(&line[i]) > (MAX_VOWEL_SZ - 1))
    {
        printf("Error: Vowel name too long: %s\n", line);
        goto pv_error;
    }
    strcpy(vowel->name, &line[i]);
    i = strlen(vowel->name) - 1;
    vowel->name[i] = '\0';
    if (score->vowels == NULL)
    {
        score->vowels = vowel;
        score->vowelsz++;
    }
    else
    {
        if (add_sorted_vowel(vowel) == 0)
            score->vowelsz++;
    }

    return 0;

pv_error:
    printf("Error getting vowel in line: '%s'\n", line);
    return -1;
}

/**
  * \par Function:
  *   parse_template
  *
  * \par Description:
  *   Parse the template file which contains the following data:
  *   - Wave function definitions
  *   - Instrument definitions
  *     - Tone templates
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

#define templateFUNC    1
#define templateINSTR   2

int parse_template(void)
{
    int i, def = 0;
    char line[CSG_MAX_LINE];
    FILE *tfd;
    csgInstrument *instr = NULL;
    csgFunction *func = NULL;

    if ((tfd = fopen(tfile, "r")) == NULL)
    {
        printf("Error: failed to open template file %s\n  %s\n", tfile, strerror(errno));
        goto ptmp_error;
    }

    while (!feof(tfd) && !(ferror(tfd)))
    {
        if (fgets(line, CSG_MAX_LINE, tfd) == NULL)
        {
            if (feof(tfd))
                break;
            else if (ferror(tfd))
            {
                printf("Error: attempting to read from template file %s\n  %s\n",
                        tfile, strerror(errno));
                goto ptmp_error;
            }
            continue;
        }
        /* Check for blank lines and comments */
        for (i=0; i < CSG_MAX_LINE; i++)
        {
            if (line[i] == '\0' || line[i] == '\n' || line[i] == '#')
            {
                i = CSG_MAX_LINE;
                break;
            }
            else if (line[i] != ' ' || line[i] == '\t')
                break;
        }
        if (i >= CSG_MAX_LINE)
            continue;

        if (strncmp(&line[i], "FUNC", 4) == 0)
        {
            def = templateFUNC;
            if ((func = (csgFunction *) csg_alloc(sizeof(csgFunction),
                          "function data")) == NULL)
                goto ptmp_error;
            i += 5;
            strcpy(func->parms, &line[i]);
            i = strlen(func->parms);
            if (func->parms[i-1] == '\n')
                func->parms[i-1] = '\0';
            if (score->functions == NULL)
                score->functions = func;
            else
            {
                func->next = score->functions;
                score->functions = func;
            }
        }

        /* Get vowels */
        else if (strncmp(&line[i], "VOWEL", 5) == 0)
        {
            i += 6;
            if (parse_vowel(&line[i]) != 0)
                goto ptmp_error;
        }

        else if (strncmp(&line[i], "INSTR", 5) == 0)
        {
            def = templateINSTR;
            if ((instr = (csgInstrument *) csg_alloc(sizeof(csgInstrument),
                          "instrument data")) == NULL)
                goto ptmp_error;
            i += 6;
            if (strlen(&line[i]) > NAME_MAX)
            {
                printf("Error: Instrument name too long:\n  %s\n", line);
                goto ptmp_error;
            }
            strcpy(instr->name, &line[i]);
            i = strlen(instr->name);
            if (instr->name[i-1] == '\n')
                instr->name[i-1] = '\0';
            if (score->instruments == NULL)
                score->instruments = instr;
            else
            {
                instr->next = score->instruments;
                score->instruments = instr;
            }
        }

        /* Get harmonic frequencies from the scale */
        else if (strncmp(&line[i], "SCALEHARM", 9) == 0)
        {
            if (instr == NULL)
            {
                printf ("Error: SCALEHARM must have an INSTR definition\n");
                goto ptmp_error;
            }
            instr->flag |= SCALEHARM;
        }

        /* Get tone definitions in same order as entered */
        else if (def == templateINSTR)
        {
            if (parse_tone(line, instr) != 0)
                goto ptmp_error;
        }
    }

    fclose(tfd);
    return 0;

ptmp_error:
    if (tfd != NULL)
        fclose(tfd);
    return -1;
}

/**
  * \par Function:
  *   parse_staffnote
  *
  * \par Description:
  *   Parse a note line of a staff file and add it to a csgStaffNote struct.
  *   It is assumed that the CSound score definitions are understood and they
  *   will not be explained.  The format of the note line is as follows:
  *
  *   <br>note start duration volume
  *   NOTE: The keyword FUND has been removed from the line.
  *   - note: Valid note found in accompanying note file
  *   - start: Relative start time which may include 2-digit decimal values
  *   - duration: Number which may include 2-digit decimal values
  *   - volume: Integer number (1 - 30000)
  *
  * \par Inputs:
  *   - line: StaffNote line to be parsed
  *   - type: StaffNote type
  *
  * \par Outputs:
  *   - csgStaffNote struct with parsed data
  *     - NULL = Error
  */

/* StaffNote types */
#define CNTYPE_STANDARD    0
#define CNTYPE_VOWEL       1

csgStaffNote *parse_staffnote(char *line, int cntype)
{
    int i = 0;
    double dnum;
    csgStaffNote *note = NULL;
    csgVowel *vowel = NULL;
    char note_name[4], vowel_name[16];

    if ((note = (csgStaffNote *) csg_alloc(sizeof(csgStaffNote), "staff note data")) == NULL)
        goto pcn_error;

    /* Get note name */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    strncpy(note_name, &line[i], 3);
    if (!( (note_name[2] >= '0' && note_name[2] <= '9') ||
           (note_name[2] >= 'a' && note_name[2] <= 'z') ||
           (note_name[2] >= 'A' && note_name[2] <= 'Z') ))
        note_name[2] = ' ';
    note_name[3] = '\0';
    if ((note->note = csg_getnote(note_name, 0, score->notesz - 1)) == NULL)
        goto pcn_error;

    /* Get start time */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (note->start = csg_getnum(&line[i])) == DBL_ERROR)
        goto pcn_error;

    /* Get duration */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (note->durat = csg_getnum(&line[i])) == DBL_ERROR)
        goto pcn_error;

    /* Get volume */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pcn_error;
    note->vol = (int) dnum;

    /* Get vowel */
    if (cntype == CNTYPE_VOWEL)
    {
        FIND_SPACE(line, i, CSG_MAX_LINE)
        SKIP_SPACE(line, i, CSG_MAX_LINE)
        strcpy(vowel_name, &line[i]);
        i = strlen(vowel_name) - 1;
        vowel_name[i] = '\0';
        if ((vowel = csg_getvowel(vowel_name, 0, score->vowelsz - 1)) == NULL)
        {
            printf("Did not find vowel\n");
            goto pcn_error;
        }
        note->vid = vowel->id;
    }
    else
        note->vid = -1;

    return note;

pcn_error:
    if (note != NULL)
    {
        free(note);
        printf("Error getting staff note in line: '%s'\n", line);
    }
    return NULL;
}

/**
  * \par Function:
  *   parse_repeat
  *
  * \par Description:
  *   Parse the repetition parameters.
  *
  *   <br>count period vol_change period_change
  *   - count: Number of repetitions
  *   - period: Time between repetitions
  *   - vol_change: Amount to change volume each iteration (+/-)
  *   - period_change: Amount to change time between repititions (/-)
  *
  * \par Inputs:
  *   - line: Repeat line to be parsed
  *   - staff: Staff to update with repeat data
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_repeat(char *line, csgStaff *staff)
{
    int i = 0;
    double dnum;

    /* Get count */
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pr_error;
    staff->repeat = (int) dnum;

    /* Get period */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || 
        (staff->period = csg_getnum(&line[i])) == DBL_ERROR)
        goto pr_error;

    /* Get volume change */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE || (dnum = csg_getnum(&line[i])) == DBL_ERROR)
        goto pr_error;
    staff->volchange = (int) dnum;

    /* Get period change */
    FIND_SPACE(line, i, CSG_MAX_LINE)
    SKIP_SPACE(line, i, CSG_MAX_LINE)
    if (i >= CSG_MAX_LINE ||
        (staff->pdchange = csg_getnum(&line[i])) == DBL_ERROR)
        goto pr_error;

    return 0;

pr_error:
    return -1;
}

/**
  * \par Function:
  *   parse_staffs
  *
  * \par Description:
  *   Parse the staves file which contains the following staff parameters:
  *   - Instrument
  *   - Notes
  *   - Start and Duration
  *   - Volume
  *
  * \par
  *   A staff is one or more notes played by a single instrument.  Two or more
  *   staffs may be played at the same start time.  The staff information is
  *   multiplied by the template data for the instrument to create a score.
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int parse_staffs(void)
{
    int i;
    char line[CSG_MAX_LINE];
    char instr_name[NAME_MAX];
    FILE *vfd;
    csgStaff *staff = NULL;
    csgInstrument *instr = NULL;
    csgStaffNote *note;

    if ((vfd = fopen(vfile, "r")) == NULL)
    {
        printf("Error: failed to open staff file %s\n  %s\n", vfile, strerror(errno));
        goto pc_error;
    }

    while (!feof(vfd) && !(ferror(vfd)))
    {
        if (fgets(line, CSG_MAX_LINE, vfd) == NULL)
        {
            if (feof(vfd))
                break;
            else if (ferror(vfd))
            {
                printf("Error: attempting to read from staff file %s\n  %s\n",
                        vfile, strerror(errno));
                goto pc_error;
            }
            continue;
        }
        /* Check for blank lines and comments */
        for (i=0; i < CSG_MAX_LINE; i++)
        {
            if (line[i] == '\0' || line[i] == '\n' || line[i] == '#')
            {
                i = CSG_MAX_LINE;
                break;
            }
            else if (line[i] != ' ' || line[i] == '\t')
                break;
        }
        if (i >= CSG_MAX_LINE)
            continue;

        /*
         * The tempo_diff modifies the tempo inversely.
         * - To increase the tempo by 10%, use "TEMP 0.9"
         * - To decrease the tempo by 10%, use "TEMP 1.1"
         */
        if (strncmp(&line[i], "TEMPO", 5) == 0)
        {
            i += 6;
            SKIP_SPACE(line, i, CSG_MAX_LINE)
            if (i >= CSG_MAX_LINE ||
                (tempo_diff = csg_getnum(&line[i])) == DBL_ERROR)
                goto pc_error;
        }
        if (strncmp(&line[i], "STAFF", 4) == 0)
        {
            if (staff != NULL && (staff->instr == NULL || staff->notes == NULL))
            {
                if (staff->name[0] == '\0')
                    printf("Warning: Staff missing instrument or notes: Unknown\n");
                else
                    printf("Warning: Staff missing instrument or notes: %s\n", staff->name);
                goto pc_error;
            }
            if ((staff = (csgStaff*) csg_alloc(sizeof(csgStaff), "staff data")) == NULL)
                goto pc_error;
            i += 5;
            if (strlen(&line[i]) > NAME_MAX)
            {
                printf("Error: Staff name too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(staff->name, &line[i]);
            i = strlen(staff->name);
            if (staff->name[i-1] == '\n')
                staff->name[i-1] = '\0';
            /* Instrument can be defined in advance for several staffs */
            if (instr != NULL)
                staff->instr = instr;
            if (score->staffs == NULL)
            {
                score->staffs = staff;
                score->ctail = staff;
            }
            else
            {
                score->ctail->next = staff;
                staff->prev = score->ctail;
                score->ctail = staff;
            }
        }

        /* TODO: Variations on repeat:
         *   - REPEATGRP: Nested repeats of multiple staffs
         *   - REPEATV: volchange is maximum, then divide each repetition by N
         *   - REPEATP: period is maximum, then divide each repetition by N
         */
        else if (strncmp(&line[i], "REPEAT", 6) == 0)
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if (strncmp(&line[i+6], "GRP", 3) == 0)
            {
                staff->flag |= REPEATGRP;
                i += 10;
            }
            else if (line[i+6] == 'V')
            {
                staff->flag |= REPEATV;
                i += 8;
            }
            else if (line[i+6] == 'P')
            {
                staff->flag |= REPEATP;
                i += 8;
            }
            else
                i += 7;
            if (parse_repeat(&line[i], staff) != 0)
                goto pc_error;
        }

        else if (strncmp(&line[i], "INSTR", 5) == 0)
        {
            if (staff == NULL)
                printf("Warning: Missing STAFF statement for: %s\n", line);
            i += 6;
            if (strlen(&line[i]) > NAME_MAX)
            {
                printf("Error: Instrument name too long:\n  %s\n", line);
                goto pc_error;
            }
            strcpy(instr_name, &line[i]);
            i = strlen(instr_name);
            if (instr_name[i-1] == '\n')
                instr_name[i-1] = '\0';
            if (score->instruments == NULL)
            {
                printf("Error: No instruments defined\n");
                goto pc_error;
            }
            instr = score->instruments;
            while (instr != NULL)
            {
                if (strcmp(instr_name, instr->name) == 0)
                    break;
                instr = instr->next;
            }
            if (instr == NULL)
            {
                printf("Error: Instrument not defined: '%s'\n", instr_name);
                goto pc_error;
            }
            if (staff != NULL)
                staff->instr = instr;
        }

        /* TODO: Harmonics and panning
         *   - VOLCHANGE: Modify amplitude of harmonics as pitch increases
         *   - ATTCHANGE, DECCHANGE, SUSCHANGE, RELCHANGE: Modify ADSR as pitch increases
         *   - PANLEFT, PANRIGHT: Provide a pan (% volume change) for staffs
         */
        else if (strncmp(&line[i], "FUND", 4) == 0)
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if ((note = (csgStaffNote *) csg_alloc(sizeof(csgStaffNote),
                          "staff note data")) == NULL)
                goto pc_error;
            i += 5;
            /* Parse note meter values */
            if ((note = parse_staffnote(&line[i], CNTYPE_STANDARD)) == NULL)
                goto pc_error;
            /* Put staff notes on list in order defined */
            if (staff->notes == NULL)
            {
                staff->notes = note;
                staff->ntail = note;
            }
            else
            {
                staff->ntail->next = note;
                staff->ntail = note;
            }
        }
        /* Voice vowel sounds */
        else if (strncmp(&line[i], "VFUND", 5) == 0)
        {
            if (staff == NULL)
            {
                printf("Error: Missing STAFF statement for: %s\n", line);
                goto pc_error;
            }
            if ((note = (csgStaffNote *) csg_alloc(sizeof(csgStaffNote),
                          "staff note data")) == NULL)
                goto pc_error;
            i += 6;
            /* Parse vowel meter values */
            if ((note = parse_staffnote(&line[i], CNTYPE_VOWEL)) == NULL)
                goto pc_error;
            /* Put staff vowel notes on list in order defined */
            if (staff->notes == NULL)
            {
                staff->notes = note;
                staff->ntail = note;
            }
            else
            {
                staff->ntail->next = note;
                staff->ntail = note;
            }
        }

    }

    fclose(vfd);
    return 0;

pc_error:
    if (vfd != NULL)
        fclose(vfd);
    return -1;
}

/**
  * \par Function:
  *   csg_get_scale_harmonic
  *
  * \par Description:
  *   This is a utility function to get a harmonic frequency from
  *   the list of notes.
  *
  * \par Inputs:
  *   - index: Index of the frequency offset
  *
  * \par Outputs:
  *   - double: Requested frequency
  *     - DBL_ERROR = Error
  */

double csg_get_scale_harmonic(int index)
{
    int idx;
    double freq;

        idx = index + basenoteidx;
        if (idx >= score->notesz)
        {
            printf("Warning: Harmonic frequency out of range: %d\n", idx);
            return(DBL_ERROR);
        }
        else
            freq = score->nfrqarr[idx].freq;

    return(freq);
}

/**
  * \par Function:
  *   csg_get_scoreline
  *
  * \par Description:
  *   This is a utility function to create the string for a tone waveform
  *   instrument line in a CSound score file.
  *
  * \par Inputs:
  *   - line: String array to hold the line
  *   - instr: The instrument for the line
  *   - note: The staff note to define the line 
  *   - tone: The staff tone to modify the values`
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *       This means a scale harmonic was out of range which is ignored for now
  */

int csg_get_scoreline(char *line, csgInstrument *instr, csgStaffNote *note, csgTone *tone)
{
    double start, durat, volume, freq;

    start = (tone->start + note->start) * tempo_diff;
    durat = (tone->durat * note->durat) * tempo_diff;

    if (tone->flag && TONE_FIXED)
        freq = tone->freq;
    else if (instr->flag & SCALEHARM)
    {
        if ((freq = csg_get_scale_harmonic((int) tone->freq)) == DBL_ERROR)
            return -1;
    }
    else
        freq = tone->freq * note->note->freq;

    volume = (tone->vol * note->vol);

    snprintf(line, CSG_MAX_LINE,
            "i%s  %.4f  %.4f  %.4f  %.4f  %s\n",
            instr->name, start, durat, volume, freq, tone->parms);

    return 0;
}

/**
  * \par Function:
  *   csg_get_simp_scoreline
  *
  * \par Description:
  *   This is a utility function to create the string for a simple waveform
  *   instrument line in a CSound score file.
  *
  * \par Inputs:
  *   - line: String array to hold the line
  *   - instr: The instrument for the line
  *   - note: The staff note to define the line 
  *   - tone: The staff tone to modify the values`
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *       This means a scale harmonic was out of range which is ignored for now
  */

int csg_get_simp_scoreline(char *line, csgInstrument *instr, csgStaffNote *note, csgSimpTone *tone)
{
    int volume;
    double start, durat, freq;

    start = (tone->start + note->start) * tempo_diff;
    durat = (tone->durat * note->durat) * tempo_diff;

    if (tone->flag && TONE_FIXED)
        freq = tone->freq;
    else if (instr->flag & SCALEHARM)
    {
        if ((freq = csg_get_scale_harmonic((int) tone->freq)) == DBL_ERROR)
            return -1;
    }
    else
        freq = tone->freq * note->note->freq;

    volume = (tone->vol * note->vol) / 1000;

    snprintf(line, CSG_MAX_LINE,
            "i%s  %.4f  %.4f  %d  %.4f  %s",
            instr->name, start, durat, volume, freq, tone->parms);

    return 0;
}

/**
  * \par Function:
  *   csg_get_vowel_scoreline
  *
  * \par Description:
  *   This is a utility function to create the string for a voice vowel waveform
  *   instrument line in a CSound score file.
  *
  * \par Inputs:
  *   - line: String array to hold the line
  *   - instr: The instrument for the line
  *   - note: The staff note to define the line 
  *   - tone: The staff tone to modify the values`
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *       This means a scale harmonic was out of range which is ignored for now
  */

int csg_get_vowel_scoreline(char *line, csgInstrument *instr, csgStaffNote *note, csgVowelTone *tone)
{
    int volume;
    double start, durat, freq;

    start = (tone->start + note->start) * tempo_diff;
    durat = (tone->durat * note->durat) * tempo_diff;

    freq = tone->freq * note->note->freq;

    volume = (tone->vol * note->vol) / 1000;

    snprintf(line, CSG_MAX_LINE,
            "i%s  %.4f  %.4f  %d  %.4f  %d  %d  %.4f  %.4f\n",
            instr->name, start, durat, volume, freq, note->vid,
            tone->tilt, tone->vibdepth, tone->vibamt);

    return 0;
}

/**
  * \par Function:
  *   csg_get_snd_scoreline
  *
  * \par Description:
  *   This is a utility function to create the string for an instrument
  *   line in a CSound score file.
  *
  * \par Inputs:
  *   - line: String array to hold the line
  *   - instr: The instrument for the line
  *   - note: The staff note to define the line 
  *   - tone: The staff tone to modify the values`
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  *       This means a scale harmonic was out of range which is ignored for now
  */

int csg_get_snd_scoreline(char *line, csgInstrument *instr, csgStaffNote *note, csgSNDTone *tone)
{
    int volume;
    double start, durat, freq;

    start = (tone->start + note->start) * tempo_diff;
    durat = (tone->durat * note->durat) * tempo_diff;

    volume = (tone->vol * note->vol) / 1000;

    freq = tone->pitch * note->note->freq;

    snprintf(line, CSG_MAX_LINE,
            "i%s  %.4f  %.4f  %d  %.4f\n",
            instr->name, start, durat, volume, freq);

    return 0;
}

/**
  * \par Function:
  *   create_score
  *
  * \par Description:
  *   Create a CSound score (*.sco) file 
  *
  * \par
  *   The CSound scores created by this program have a function area followed
  *   by the tones definitions. The function fields are defined in the Template
  *   file and used as is.  The notes are created by combining the Note,
  *   Template, and Staff data as follows:
  *   - Note data: This is simply the frequency in Hz of the fundamental
  *   - Template data: The Instrument definition is a list of tones that
  *     work as harmonics to the fundamental.  They are calculated based on
  *     the frequency of the fundamental.
  *   - Staff data: This is a list of notes with the start time and duration,
  *     and the volume at the time the staff is played.
  *
  * \par Inputs:
  *   - None
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - <0 = Error
  */

int create_score(void)
{
    char sbuf[CSG_MAX_LINE];
    FILE *sfd;
    csgFunction *function;
    csgTone *tone;
    csgSimpTone *stone;
    csgVowelTone *vtone;
    csgSNDTone *sndtone;
    csgStaff  *staff, *tch1, *tch2;
    csgStaffNote *chnote;

    if ((sfd = fopen(sfile, "w")) == NULL)
    {
        printf("Error: failed to open staff file %s\n  %s\n", sfile, strerror(errno));
        goto cs_error;
    }

    if (fputs(CSG_HEADER, sfd) != 0)
    {
        SCORE_ERROR(sfd, "data", cs_error)
    }

    function = score->functions;
    while (function != NULL)
    {
        sprintf(sbuf, "%s\n\n", function->parms);
        if (fputs(sbuf, sfd) != 0)
        {
            SCORE_ERROR(sfd, "function data", cs_error)
        }
        function = function->next;
    }

    staff = score->staffs;
    while (staff != NULL)
    {
        sprintf(sbuf, "; %s\n", staff->name);
        if (fputs(sbuf, sfd) != 0)
        {
            SCORE_ERROR(sfd, "staff name", cs_error)
        }
        chnote = staff->notes;
        while (chnote != NULL)
        {
            basenoteidx = chnote->note->index;
            tone = staff->instr->tones;
            while (tone != NULL)
            {
                if (csg_get_scoreline(sbuf, staff->instr, chnote, tone) == 0)
                {
                    if (fputs(sbuf, sfd) != 0)
                    {
                        SCORE_ERROR(sfd, "instrument line", cs_error)
                    }
                }
                tone = tone->next;
            }
            stone = staff->instr->stones;
            while (stone != NULL)
            {
                if (csg_get_simp_scoreline(sbuf, staff->instr, chnote, stone) == 0)
                {
                    if (fputs(sbuf, sfd) != 0)
                    {
                        SCORE_ERROR(sfd, "instrument line", cs_error)
                    }
                }
                stone = stone->next;
            }
            vtone = staff->instr->vtones;
            while (vtone != NULL)
            {
                if (csg_get_vowel_scoreline(sbuf, staff->instr, chnote, vtone) == 0)
                {
                    if (fputs(sbuf, sfd) != 0)
                    {
                        SCORE_ERROR(sfd, "instrument line", cs_error)
                    }
                }
                vtone = vtone->next;
            }
            sndtone = staff->instr->sndtones;
            while (sndtone != NULL)
            {
                if (csg_get_snd_scoreline(sbuf, staff->instr, chnote, sndtone) == 0)
                {
                    if (fputs(sbuf, sfd) != 0)
                    {
                        SCORE_ERROR(sfd, "instrument line", cs_error)
                    }
                }
                sndtone = sndtone->next;
            }
            if (staff->repeat > 0)
            {
                chnote->start += staff->period;
                chnote->vol += staff->volchange;
                if (chnote->vol < 0)
                    chnote->vol = 0;
            }
            chnote = chnote->next;
        }
        /* Handle repeated notes */
        if (staff->repeat > 0)
        {
            staff->period += staff->pdchange;
            if (staff->period < 0)
                staff->period = 0;
            staff->repeat--;
            if (staff->next != NULL && 
                staff->notes->start > staff->next->notes->start)
            {
                tch1 = staff;
                staff = staff->next;
                tch2 = staff;
                tch1->period += tch1->pdchange;
                if (tch1->prev != NULL)
                    tch1->prev->next = tch1->next;
                else if (score->staffs == tch1)
                    score->staffs = tch1->next;
                if (tch1->next != NULL)
                    tch1->next->prev = tch1->prev;
                tch1->next = tch1->prev = NULL;
                while (tch2 != NULL)
                {
                    if (tch1->notes->start >= tch2->notes->start)
                        tch2 = tch2->next;
                    else
                        break;
                }
                if (tch2 == NULL)
                {
                    score->ctail->next = tch1;
                    tch1->prev = score->ctail;
                    score->ctail = tch1;
                }
                else
                {
                    if (tch2->prev != NULL)
                    {
                    tch1->next = tch2->prev->next;
                    tch2->prev->next = tch1;
                    tch1->prev = tch2->prev;
                    tch2->prev = tch1;
                    }
                    else
                    {
                        if (score->staffs != NULL)
                        {
                            tch1->next = score->staffs;
                            score->staffs->prev = tch1;
                        }
                        else
                            score->ctail = tch1;
                        score->staffs = tch1;
                    }
                }
            }
            else
            {
            }
        }
        else
            staff = staff->next;
    }

    fclose(sfd);
    return 0;

cs_error:
    if (sfd != NULL)
        fclose(sfd);
    return -1;
}

/**
  * \par Function:
  *   main
  *
  * \par Description:
  *   The command line arguments are checked here.  Then the csgScore anchor is
  *   initializaed.  If this is successful, then the configuration file parsers
  *   are called and the score is created.
  *
  * \par Inputs:
  *   - See command line arguments
  *
  * \par Outputs:
  *   - int: Status
  *     - 0 = OK
  *     - 1 = Error
  */

/*
 * TODO:
 * - Plugins
 * - Sections
 * -? CSD files
 *
 *
 */

#define DEBUG_NOTE      0x01
#define DEBUG_TEMPLATE  0x02
#define DEBUG_STAFF     0x04

int main (int argc, char *argv[])
{
    int opt, i;
    int debug = 0;
    char *ept;
    csgNoteFiles *nfiles;
    csgNote *note = NULL;
    csgVowel *vowel = NULL;

    if ((score = (csgScore *) csg_alloc(sizeof(csgScore), "score data")) == NULL)
        return 1;

    strcpy(sfile, DFLT_SCO_FILE);
    strcpy(tfile, DFLT_TMPLT_FILE);
    strcpy(vfile, DFLT_STAFF_FILE);
    if (argc > 1)
    {
        // Parse command line arguments
        while ((opt = getopt(argc, argv, "d:n:s:t:v:")) != -1)
        {
            switch (opt)
            {
              case 'd':
                  debug = (int) strtol(optarg, &ept, 10);
                  if (*ept != '\0' || debug < 0)
                  {
                      printf("Error: invalid debug code, ignored: %s\n", optarg);
                      debug = 0;
                  }
                  break;
              case 'n':
                  if ((nfiles = (csgNoteFiles *) csg_alloc(sizeof(csgNoteFiles),
                                 "file name data")) == NULL)
                      return 1;
                  strncpy(nfiles->name, optarg, CSG_MAX_FN);
                  nfiles->name[CSG_MAX_FN - 1] = '\0';
                  nfiles->next = score->nfiles;
                  score->nfiles = nfiles;
                  break;
              case 's':
                  strncpy(sfile, optarg, CSG_MAX_FN);
                  sfile[CSG_MAX_FN - 1] = '\0';
                  break;
              case 't':
                  strncpy(tfile, optarg, CSG_MAX_FN);
                  tfile[CSG_MAX_FN - 1] = '\0';
                  break;
              case 'v':
                  strncpy(vfile, optarg, CSG_MAX_FN);
                  vfile[CSG_MAX_FN - 1] = '\0';
                  break;
              default:
                  printf("\ncsnd_gen Version %s\n", CSG_VER);
                  printf("\ncsnd_gen [arguments]:\n");
                  printf("  -d: debug code: Note = 1, Template = 2, Staff = 4\n");
                  printf("      Values can be ORed for multiple printouts\n");
                  printf("  -n: note_file: Name of note files, enter -n for each\n");
                  printf("      Default: %s\n", DFLT_NOTE_FILE);
                  printf("  -s: sco_file: Name of sco file\n");
                  printf("      Default: %s\n", DFLT_SCO_FILE);
                  printf("  -t: template_file: Name of template file\n");
                  printf("      Default: %s\n", DFLT_TMPLT_FILE);
                  printf("  -v: staves_file: Name of staves file\n");
                  printf("      Default: %s\n", DFLT_STAFF_FILE);
                  printf("\n");
                  return 0;
                  break;
            }
        }
    }

    printf("\nStarting CSound Generator\n");

    /* TODO: Add Formants
     * - Formants are defined as vowels (or consonants) such as a e oo ou
     *    FORMANT1 <name> <vol> <freq>
     *     freq = multiplier above 220
     *     start/end same as fundamental
     *     waveform is sine
     *     ADSR is fixed at 0.1 0.5 0.4 0.2
     * See file:///usr/share/doc/csound-doc/html/MiscFormants.html
     * for tables of formant frequencies
     */
    /* The configuration files must be parsed in the following order:
       - Notes
       - Templates
       - Staffs  */
    if (score->nfiles == NULL)
    {
        if ((nfiles = (csgNoteFiles *) csg_alloc(sizeof(csgNoteFiles),
                       "file name data")) == NULL)
            return 1;
        strcpy(nfiles->name, DFLT_NOTE_FILE);
        score->nfiles = nfiles;
    }
    nfiles = score->nfiles;
    while (nfiles != NULL)
    {
        if (parse_notes(nfiles->name) != 0)
            return 1;
        nfiles = nfiles->next;
    }
    /* Create vector of note structs sorted by note name for binary searches */
    i = score->notesz * sizeof(csgNoteArray);
    if ((score->narray = (csgNoteArray *) csg_alloc(i, "score note data")) == NULL)
        return 1;
    i = score->notesz * sizeof(csgNoteFreqArray);
    if ((score->nfrqarr = (csgNoteFreqArray *) csg_alloc(i, "score note frequency data")) == NULL)
        return 1;
    note = score->notes;
    i = 0;
    while (note != NULL && i < score->notesz)
    {
        strcpy(score->narray[i].name, note->name);
        score->narray[i].note = note;
        score->nfrqarr[i].freq = note->freq;
        score->nfrqarr[i].note = note;
        i++;
        note = note->next;
    }
    /* Sort frequency array */
    qsort(score->nfrqarr, score->notesz, sizeof(csgNoteFreqArray), csg_sortnotes);
    for (i=0; i < score->notesz; i++)
    {
        score->nfrqarr[i].note->index = i;
    }
    if (debug & DEBUG_NOTE)
        csg_print_data(TYPE_NOTE);
    if (debug & DEBUG_NOTE)
        csg_print_data(TYPE_NOTEF);

    if (parse_template() != 0)
        return 1;
    if (debug & DEBUG_TEMPLATE)
        csg_print_data(TYPE_INSTR | TYPE_FUNC);
    /* Create vector of vowel structs sorted by vowel name for binary searches */
    if ((i = score->vowelsz * sizeof(csgVowelArray)) > 0)
    {
        if ((score->varray = (csgVowelArray *) csg_alloc(i, "score vowel data")) == NULL)
            return 1;
        vowel = score->vowels;
        i = 0;
        while (vowel != NULL && i < score->vowelsz)
        {
            strcpy(score->varray[i].name, vowel->name);
            score->varray[i].vowel = vowel;
            i++;
            vowel = vowel->next;
        }
    }

    if (parse_staffs() != 0)
        return 1;
    if (debug & DEBUG_STAFF)
        csg_print_data(TYPE_STAFF);

    if (create_score() != 0)
        return 1;

    if (debug & DEBUG_STAFF)
        csg_print_data(TYPE_STAFF);

    printf("Completed CSound Generator using score file %s\n\n", sfile);
    return 0;
}


